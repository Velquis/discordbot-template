// commands/admin/savechat.js
import { SlashCommandBuilder, PermissionFlagsBits } from 'discord.js';
import fs from 'fs';
import path from 'path';

// Configura√ß√£o do cargo (substitua pelo ID real do seu cargo de Staff)
const STAFF_ROLE_ID = '123456789012345678'; // üëà ID do cargo da Staff

export const command = {
    data: new SlashCommandBuilder()
        .setName('savechat')
        .setDescription('Saves messages from this channel to a text file (Admin/Staff Only)')
        .addIntegerOption(option =>
            option.setName('limit')
                .setDescription('Max messages to save (100-5000, default: 500)')
                .setMinValue(100)
                .setMaxValue(5000)
        )
        .setDefaultMemberPermissions(0x8), // Mant√©m a flag de admin para visibilidade
    
    async execute(interaction) {
        // Verifica se √© admin ou tem o cargo de Staff
        const isAdmin = interaction.member.permissions.has(PermissionFlagsBits.Administrator);
        const isStaff = interaction.member.roles.cache.has(STAFF_ROLE_ID);

        if (!isAdmin && !isStaff) {
            return interaction.reply({
                content: '‚ùå This command is restricted to administrators and staff only.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });
        
        const requestedLimit = interaction.options.getInteger('limit') || 500;
        const channel = interaction.channel;
        const MAX_PER_FETCH = 100;
        const DELAY_BETWEEN_FETCHES = 1000;
        
        try {
            let messages = [];
            let lastId;
            let totalFetched = 0;
            
            await interaction.editReply({
                content: `‚è≥ Collecting messages (0/${requestedLimit})...`,
                ephemeral: true
            });

            while (totalFetched < requestedLimit) {
                const fetchLimit = Math.min(MAX_PER_FETCH, requestedLimit - totalFetched);
                const options = { limit: fetchLimit };
                if (lastId) options.before = lastId;

                const fetched = await channel.messages.fetch(options);
                if (fetched.size === 0) break;

                messages.push(...fetched.values());
                lastId = fetched.last().id;
                totalFetched += fetched.size;

                if (totalFetched % 100 === 0) {
                    await interaction.editReply({
                        content: `‚è≥ Collecting messages (${totalFetched}/${requestedLimit})...`,
                        ephemeral: true
                    });
                }

                if (totalFetched < requestedLimit && fetched.size === MAX_PER_FETCH) {
                    await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_FETCHES));
                }
            }

            let content = `Chat log from #${channel.name} in ${channel.guild.name}\n`;
            content += `Generated at ${new Date().toISOString()}\n`;
            content += `Generated by: ${interaction.user.tag} (${interaction.user.id})\n`;
            content += `Total messages: ${messages.length}\n\n`;
            
            messages.reverse().forEach(msg => {
                content += `[${msg.createdAt.toISOString()}] ${msg.author.username}: ${msg.cleanContent || msg.content}\n`;
                if (msg.attachments.size > 0) {
                    content += `[Attachments: ${Array.from(msg.attachments.values()).map(a => a.url).join(', ')}]\n`;
                }
                if (msg.embeds.length > 0) {
                    content += `[Embeds: ${msg.embeds.length}]\n`;
                }
                if (msg.stickers.size > 0) {
                    content += `[Stickers: ${Array.from(msg.stickers.values()).map(s => s.name).join(', ')}]\n`;
                }
            });

            const fileName = `chatlog_${channel.id}_${Date.now()}.txt`;
            const filePath = path.join(process.cwd(), fileName);
            fs.writeFileSync(filePath, content);
            
            await interaction.editReply({
                content: `‚úÖ Successfully saved ${messages.length} messages`,
                files: [filePath],
                ephemeral: true
            });
            
            setTimeout(() => fs.unlink(filePath, () => {}), 5000);
            
        } catch (error) {
            console.error('Error saving chat:', error);
            await interaction.editReply({
                content: '‚ùå Failed to save chat messages: ' + error.message,
                ephemeral: true
            });
        }
    }
};